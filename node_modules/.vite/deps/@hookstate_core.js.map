{
  "version": 3,
  "sources": ["../../../../ui/node_modules/.pnpm/@hookstate+core@3.0.13/node_modules/@hookstate/core/node_modules/tslib/tslib.es6.js", "../../../../ui/node_modules/.pnpm/@hookstate+core@3.0.13/node_modules/@hookstate/core/src/index.ts"],
  "sourcesContent": ["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n", "import React from 'react';\r\n\r\n///\r\n/// EXPORTED SYMBOLS (LIBRARY INTERFACE)\r\n///\r\n\r\n/**\r\n * 'JSON path' from root of a state object to a nested property.\r\n * Return type of [StateMethod.path](#readonly-path).\r\n *\r\n * For example, an object `{ a: [{ b: 1 }, { 1000: 'value' }, '3rd'] }`,\r\n * has got the following paths pointing to existing properties:\r\n *\r\n * - `[]`\r\n * - `['a']`\r\n * - `['a', 0]`\r\n * - `['a', 0, 'b']`\r\n * - `['a', 1]`\r\n * - `['a', 1, 1000]`\r\n * - `['a', 2]`\r\n */\r\nexport type Path = ReadonlyArray<string | number>;\r\n\r\n/**\r\n * Type of an argument of [StateMethods.set](#set).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type SetStateAction<S> = (S | Promise<S>) | ((prevState: S) => (S | Promise<S>));\r\n\r\n/**\r\n * Type of an argument of [StateMethods.merge](#merge).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type SetPartialStateAction<S> =\r\n    S extends ReadonlyArray<(infer U)> ?\r\n        ReadonlyArray<U> | Record<number, U> | ((prevValue: S) => (ReadonlyArray<U> | Record<number, U>)) :\r\n    S extends object | string ? Partial<S> | ((prevValue: S) => Partial<S>) :\r\n    React.SetStateAction<S>;\r\n\r\n/**\r\n * Type of an argument of [createState](#createstate) and [useState](#usestate).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type SetInitialStateAction<S> = S | Promise<S> | (() => S | Promise<S>)\r\n\r\n/**\r\n * Special symbol which might be returned by onPromised callback of [StateMethods.map](#map) function.\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/asynchronous-state#executing-an-action-when-state-is-loaded)\r\n */\r\nexport const postpone = Symbol('postpone')\r\n\r\n/**\r\n * Special symbol which might be used to delete properties\r\n * from an object calling [StateMethods.set](#set) or [StateMethods.merge](#merge).\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/nested-state#deleting-existing-element)\r\n */\r\nexport const none = Symbol('none') as StateValueAtPath;\r\n\r\n/**\r\n * Return type of [StateMethods.keys](#readonly-keys).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type InferredStateKeysType<S> =\r\n    S extends ReadonlyArray<infer _> ? ReadonlyArray<number> :\r\n    S extends null ? undefined :\r\n    S extends object ? ReadonlyArray<keyof S> :\r\n    undefined;\r\n\r\n/**\r\n * Return type of [StateMethods.map()](#map).\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport type InferredStateOrnullType<S> =\r\n    S extends undefined ? undefined :\r\n    S extends null ? null : State<S>;\r\n\r\n/**\r\n * For plugin developers only.\r\n * An instance to manipulate the state in more controlled way.\r\n * \r\n * @typeparam S Type of a value of a state\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/writing-plugin)\r\n */\r\nexport interface PluginStateControl<S> {\r\n    /**\r\n     * Get state value, but do not leave the traces of reading it.\r\n     */\r\n    getUntracked(): S;\r\n    /**\r\n     * Set new state value, but do not trigger rerender.\r\n     * \r\n     * @param newValue new value to set to a state.\r\n     */\r\n    setUntracked(newValue: SetStateAction<S>): Path[];\r\n    /**\r\n     * Merge new state value, but do not trigger rerender.\r\n     * \r\n     * @param mergeValue new partial value to merge with the current state value and set.\r\n     */\r\n    mergeUntracked(mergeValue: SetPartialStateAction<S>): Path[];\r\n    /**\r\n     * Trigger rerender for hooked states, where values at the specified paths are used.\r\n     * \r\n     * @param paths paths of the state variables to search for being used by components and rerender\r\n     */\r\n    rerender(paths: Path[]): void;\r\n}\r\n\r\n/**\r\n * An interface to manage a state in Hookstate.\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport interface StateMethods<S> {\r\n    /**\r\n     * 'Javascript' object 'path' to an element relative to the root object\r\n     * in the state. For example:\r\n     *\r\n     * ```tsx\r\n     * const state = useState([{ name: 'First Task' }])\r\n     * state.path IS []\r\n     * state[0].path IS [0]\r\n     * state.[0].name.path IS [0, 'name']\r\n     * ```\r\n     */\r\n    readonly path: Path;\r\n\r\n    /**\r\n     * Return the keys of nested states.\r\n     * For a given state of [State](#state) type,\r\n     * `state.keys` will be structurally equal to Object.keys(state),\r\n     * with two minor difference:\r\n     * 1. if `state.value` is an array, the returned result will be\r\n     * an array of numbers, not strings like with `Object.keys`.\r\n     * 2. if `state.value` is not an object, the returned result will be undefined.\r\n     */\r\n    readonly keys: InferredStateKeysType<S>;\r\n\r\n    /**\r\n     * Unwraps and returns the underlying state value referred by\r\n     * [path](#readonly-path) of this state instance.\r\n     *\r\n     * It returns the same result as [StateMethods.get](#get) method.\r\n     *\r\n     * This property is more useful than [get](#get) method for the cases,\r\n     * when a value may hold null or undefined values.\r\n     * Typescript compiler does not handle elimination of undefined with get(),\r\n     * like in the following examples, but value does:\r\n     *\r\n     * ```tsx\r\n     * const state = useState<number | undefined>(0)\r\n     * const myvalue: number = state.value\r\n     *      ? state.value + 1\r\n     *      : 0; // <-- compiles\r\n     * const myvalue: number = state.get()\r\n     *      ? state.get() + 1\r\n     *      : 0; // <-- does not compile\r\n     * ```\r\n     */\r\n    readonly value: S;\r\n\r\n    /**\r\n     * True if state value is not yet available (eg. equal to a promise)\r\n     */\r\n    readonly promised: boolean;\r\n    \r\n    /**\r\n     * If a state was set to a promise and the promise was rejected,\r\n     * this property will return the error captured from the promise rejection\r\n     */\r\n    readonly error: StateErrorAtRoot | undefined;\r\n    \r\n    /**\r\n     * Unwraps and returns the underlying state value referred by\r\n     * [path](#readonly-path) of this state instance.\r\n     *\r\n     * It returns the same result as [StateMethods.value](#readonly-value) method.\r\n     */\r\n    get(): S;\r\n    \r\n    /**\r\n     * Sets new value for a state.\r\n     * If `this.path === []`,\r\n     * it is similar to the `setState` variable returned by `React.useState` hook.\r\n     * If `this.path !== []`, it sets only the segment of the state value, pointed out by the path.\r\n     * Unlike [merge](#merge) method, this method will not accept partial updates.\r\n     * Partial updates can be also done by walking the nested states and setting those.\r\n     *\r\n     * @param newValue new value to set to a state.\r\n     * It can be a value, a promise resolving to a value\r\n     * (only if [this.path](#readonly-path) is `[]`),\r\n     * or a function returning one of these.\r\n     * The function receives the current state value as an argument.\r\n     */\r\n    set(newValue: SetStateAction<S>): void;\r\n    \r\n    /**\r\n     * Similarly to [set](#set) method updates state value.\r\n     *\r\n     * - If current state value is an object, it does partial update for the object.\r\n     * - If state value is an array and the argument is an array too,\r\n     * it concatenates the current value with the value of the argument and sets it to the state.\r\n     * - If state value is an array and the `merge` argument is an object,\r\n     * it does partial update for the current array value.\r\n     * - If current state value is a string, it concatenates the current state\r\n     * value with the argument converted to string and sets the result to the state.\r\n     */\r\n    merge(newValue: SetPartialStateAction<S>): void;\r\n    \r\n    /**\r\n     * Returns nested state by key.\r\n     * `state.nested('myprop')` returns the same as `state.myprop` or `state['myprop']`,\r\n     * but also works for properties, which names collide with names of state methods.\r\n     * \r\n     * [Learn more about nested states...](https://hookstate.js.org/docs/nested-state)\r\n     * \r\n     * @param key child property name or index\r\n     */\r\n    nested<K extends keyof S>(key: K): State<S[K]>;\r\n    \r\n    /**\r\n     * Runs the provided action callback with optimised re-rendering.\r\n     * Updating state within a batch action does not trigger immediate rerendering.\r\n     * Instead, all required rerendering is done once the batch is finished.\r\n     * \r\n     * [Learn more about batching...](https://hookstate.js.org/docs/performance-batched-updates\r\n     * \r\n     * @param action callback function to execute in a batch\r\n     * \r\n     * @param context custom user's value, which is passed to plugins\r\n     */\r\n    batch<R, C>(\r\n        action: (s: State<S>) => R,\r\n        context?: Exclude<C, Function>\r\n    ): R;\r\n\r\n    /**\r\n     * If state value is null or undefined, returns state value.\r\n     * Otherwise, it returns this state instance but\r\n     * with null and undefined removed from the type parameter.\r\n     * \r\n     * [Learn more...](https://hookstate.js.org/docs/nullable-state)\r\n     */\r\n    ornull: InferredStateOrnullType<S>;\r\n\r\n    /**\r\n     * Adds plugin to the state.\r\n     * \r\n     * [Learn more...](https://hookstate.js.org/docs/extensions-overview)\r\n     */\r\n    attach(plugin: () => Plugin): State<S>\r\n    \r\n    /**\r\n     * For plugin developers only.\r\n     * It is a method to get the instance of the previously attached plugin.\r\n     * If a plugin has not been attached to a state,\r\n     * it returns an Error as the first element.\r\n     * A plugin may trhow an error to indicate that plugin has not been attached.\r\n     * \r\n     * [Learn more...](https://hookstate.js.org/docs/writing-plugin)\r\n     */\r\n    attach(pluginId: symbol): [PluginCallbacks | Error, PluginStateControl<S>]\r\n}\r\n\r\n/**\r\n * Mixin for the [StateMethods](#interfacesstatemethodsmd) for a [State](#state),\r\n * which can be destroyed by a client.\r\n */\r\nexport interface StateMethodsDestroy {\r\n    /**\r\n     * Destroys an instance of a state, so\r\n     * it can clear the allocated native resources (if any)\r\n     * and can not be used anymore after it has been destroyed.\r\n     */\r\n    destroy(): void;\r\n}\r\n\r\n/**\r\n * Type of a result of [createState](#createstate) and [useState](#usestate) functions\r\n * \r\n * @typeparam S Type of a value of a state\r\n * \r\n * [Learn more about global states...](https://hookstate.js.org/docs/global-state)\r\n * [Learn more about local states...](https://hookstate.js.org/docs/local-state)\r\n * [Learn more about nested states...](https://hookstate.js.org/docs/nested-state)\r\n */\r\nexport type State<S> = StateMethods<S> & (\r\n    S extends ReadonlyArray<(infer U)> ? ReadonlyArray<State<U>> :\r\n    S extends object ? Omit<\r\n        { readonly [K in keyof Required<S>]: State<S[K]>; },\r\n        keyof StateMethods<S> | keyof StateMethodsDestroy\r\n    > : {}\r\n);\r\n\r\n/**\r\n * For plugin developers only.\r\n * Type alias to highlight the places where we are dealing with root state value.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\r\nexport type StateValueAtRoot = any; //tslint:disable-line: no-any\r\n/**\r\n * For plugin developers only.\r\n * Type alias to highlight the places where we are dealing with nested state value.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\r\nexport type StateValueAtPath = any; //tslint:disable-line: no-any\r\n/**\r\n * For plugin developers only.\r\n * Type alias to highlight the places where we are dealing with state error.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\r\nexport type StateErrorAtRoot = any; //tslint:disable-line: no-any\r\n/**\r\n * For plugin developers only.\r\n * Type alias to highlight the places where we are dealing with context value.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\r\nexport type AnyContext = any; //tslint:disable-line: no-any\r\n\r\n/**\r\n * For plugin developers only.\r\n * PluginCallbacks.onSet argument type.\r\n */\r\nexport interface PluginCallbacksOnSetArgument {\r\n    readonly path: Path,\r\n    readonly state?: StateValueAtRoot,\r\n    /**\r\n     * **A note about previous values and merging:**\r\n     * State values are muteable in Hookstate for performance reasons. This causes a side effect in the merge operation.\r\n     * While merging, the previous state object is mutated as the desired changes are applied. This means the value of\r\n     * `previous` will reflect the merged changes as well, matching the new `state` value rather than the previous\r\n     * state value. As a result, the `previous` property is unreliable when merge is used. The\r\n     * [merged](#optional-readonly-merged) property can be used to detect which values were merged in but it will not\r\n     * inform you whether those values are different from the previous state.\r\n     *\r\n     * As a workaround, you can [batch state updates](https://hookstate.js.org/docs/performance-batched-updates) or\r\n     * replace merge calls with the immutable-style set operation like so:\r\n     *\r\n     * ```\r\n     * state.set(p => {\r\n     *     let copy = p.clone(); /// here it is up to you to define how to clone the current state\r\n     *     copy.field = 'new value for field';\r\n     *     delete copy.fieldToDelete;\r\n     *     return copy;\r\n     * })\r\n     * ```\r\n     */\r\n    readonly previous?: StateValueAtPath,\r\n    readonly value?: StateValueAtPath,\r\n    readonly merged?: StateValueAtPath,\r\n}\r\n\r\n/**\r\n * For plugin developers only.\r\n * PluginCallbacks.onDestroy argument type.\r\n */\r\nexport interface PluginCallbacksOnDestroyArgument {\r\n    readonly state?: StateValueAtRoot,\r\n}\r\n\r\n/**\r\n * For plugin developers only.\r\n * PluginCallbacks.onBatchStart/Finish argument type.\r\n */\r\nexport interface PluginCallbacksOnBatchArgument {\r\n    readonly path: Path,\r\n    readonly state?: StateValueAtRoot,\r\n    readonly context?: AnyContext,\r\n}\r\n\r\n/**\r\n * For plugin developers only.\r\n * Set of callbacks, a plugin may subscribe to.\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/writing-plugin)\r\n */\r\nexport interface PluginCallbacks {\r\n    readonly onSet?: (arg: PluginCallbacksOnSetArgument) => void,\r\n    readonly onDestroy?: (arg: PluginCallbacksOnDestroyArgument) => void,\r\n    readonly onBatchStart?: (arg: PluginCallbacksOnBatchArgument) => void,\r\n    readonly onBatchFinish?: (arg: PluginCallbacksOnBatchArgument) => void,\r\n};\r\n\r\n/**\r\n * For plugin developers only.\r\n * Hookstate plugin specification and factory method.\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/writing-plugin)\r\n */\r\nexport interface Plugin {\r\n    /**\r\n     * Unique identifier of a plugin.\r\n     */\r\n    readonly id: symbol;\r\n    /**\r\n     * Initializer for a plugin when it is attached for the first time.\r\n     */\r\n    readonly init?: (state: State<StateValueAtRoot>) => PluginCallbacks;\r\n}\r\n\r\n/**\r\n * Creates new state and returns it.\r\n *\r\n * You can create as many global states as you need.\r\n *\r\n * When you the state is not needed anymore,\r\n * it should be destroyed by calling\r\n * `destroy()` method of the returned instance.\r\n * This is necessary for some plugins,\r\n * which allocate native resources,\r\n * like subscription to databases, broadcast channels, etc.\r\n * In most cases, a global state is used during\r\n * whole life time of an application and would not require\r\n * destruction. However, if you have got, for example,\r\n * a catalog of dynamically created and destroyed global states,\r\n * the states should be destroyed as advised above.\r\n *\r\n * @param initial Initial value of the state.\r\n * It can be a value OR a promise,\r\n * which asynchronously resolves to a value,\r\n * OR a function returning a value or a promise.\r\n *\r\n * @typeparam S Type of a value of the state\r\n *\r\n * @returns [State](#state) instance,\r\n * which can be used directly to get and set state value\r\n * outside of React components.\r\n * When you need to use the state in a functional `React` component,\r\n * pass the created state to [useState](#usestate) function and\r\n * use the returned result in the component's logic.\r\n */\r\nexport function createState<S>(\r\n    initial: SetInitialStateAction<S>\r\n): State<S> & StateMethodsDestroy {\r\n    const methods = createStore(initial).toMethods();\r\n    const devtools = createState[DevToolsID]\r\n    if (devtools) {\r\n        methods.attach(devtools)\r\n    }\r\n    return methods.self as State<S> & StateMethodsDestroy;\r\n}\r\n\r\n/**\r\n * Enables a functional React component to use a state,\r\n * either created by [createState](#createstate) (*global* state) or\r\n * derived from another call to [useState](#usestate) (*scoped* state).\r\n *\r\n * The `useState` forces a component to rerender every time, when:\r\n * - a segment/part of the state data is updated *AND only if*\r\n * - this segment was **used** by the component during or after the latest rendering.\r\n *\r\n * For example, if the state value is `{ a: 1, b: 2 }` and\r\n * a component uses only `a` property of the state, it will rerender\r\n * only when the whole state object is updated or when `a` property is updated.\r\n * Setting the state value/property to the same value is also considered as an update.\r\n *\r\n * A component can use one or many states,\r\n * i.e. you may call `useState` multiple times for multiple states.\r\n *\r\n * The same state can be used by multiple different components.\r\n *\r\n * @param source a reference to the state to hook into\r\n *\r\n * The `useState` is a hook and should follow React's rules of hooks.\r\n *\r\n * @returns an instance of [State](#state),\r\n * which **must be** used within the component (during rendering\r\n * or in effects) or it's children.\r\n */\r\nexport function useState<S>(\r\n    source: State<S>\r\n): State<S>;\r\n/**\r\n * This function enables a functional React component to use a state,\r\n * created per component by [useState](#usestate) (*local* state).\r\n * In this case `useState` behaves similarly to `React.useState`,\r\n * but the returned instance of [State](#state)\r\n * has got more features.\r\n *\r\n * When a state is used by only one component, and maybe it's children,\r\n * it is recommended to use *local* state instead of *global*,\r\n * which is created by [createState](#createstate).\r\n *\r\n * *Local* (per component) state is created when a component is mounted\r\n * and automatically destroyed when a component is unmounted.\r\n *\r\n * The same as with the usage of a *global* state,\r\n * `useState` forces a component to rerender when:\r\n * - a segment/part of the state data is updated *AND only if*\r\n * - this segment was **used** by the component during or after the latest rendering.\r\n *\r\n * You can use as many local states within the same component as you need.\r\n *\r\n * @param source An initial value state.\r\n *\r\n * @returns an instance of [State](#state),\r\n * which **must be** used within the component (during rendering\r\n * or in effects) or it's children.\r\n */\r\nexport function useState<S>(\r\n    source: SetInitialStateAction<S>\r\n): State<S>;\r\nexport function useState<S>(\r\n    source: SetInitialStateAction<S> | State<S>\r\n): State<S> {\r\n    return useHookstate(source as State<S>);\r\n}\r\n\r\n/**\r\n * Alias to [useState](#usestate) which provides a workaround\r\n * for [React 20613 bug](https://github.com/facebook/react/issues/20613)\r\n */\r\nexport function useHookstate<S>(\r\n    source: State<S>\r\n): State<S>;\r\n/**\r\n * Alias to [useState](#usestate) which provides a workaround\r\n * for [React 20613 bug](https://github.com/facebook/react/issues/20613)\r\n */\r\nexport function useHookstate<S>(\r\n    source: SetInitialStateAction<S>\r\n): State<S>;\r\nexport function useHookstate<S>(\r\n    source: SetInitialStateAction<S> | State<S>\r\n): State<S> {\r\n    const parentMethods = typeof source === 'object' && source !== null ?\r\n        source[self] as StateMethodsImpl<S> | undefined :\r\n        undefined;\r\n    if (parentMethods) {\r\n        if (parentMethods.isMounted) {\r\n            // Scoped state mount\r\n            // eslint-disable-next-line react-hooks/rules-of-hooks\r\n            const [, setValue] = React.useState({});\r\n            return useSubscribedStateMethods<S>(\r\n                parentMethods.state,\r\n                parentMethods.path,\r\n                () => setValue({}),\r\n                parentMethods).self;\r\n        } else {\r\n            // Global state mount or destroyed link\r\n            // eslint-disable-next-line react-hooks/rules-of-hooks\r\n            const [value, setValue] = React.useState({ state: parentMethods.state });\r\n            let state =  useSubscribedStateMethods<StateValueAtRoot>(\r\n                value.state,\r\n                RootPath,\r\n                () => setValue({ state: value.state }),\r\n                value.state).self;\r\n            for (let ind = 0; ind < parentMethods.path.length; ind += 1) {\r\n                state = state.nested(parentMethods.path[ind]);\r\n            }\r\n            return state as State<S>;\r\n        }\r\n    } else {\r\n        // Local state mount\r\n        // eslint-disable-next-line react-hooks/rules-of-hooks\r\n        const [value, setValue] = React.useState(() => ({ state: createStore(source) }));\r\n        const result = useSubscribedStateMethods<S>(\r\n            value.state,\r\n            RootPath,\r\n            () => setValue({ state: value.state }),\r\n            value.state);\r\n\r\n        if (isDevelopmentMode) {\r\n            // This is a workaround for the issue:\r\n            // https://github.com/avkonst/hookstate/issues/109\r\n            // See technical notes on React behavior here:\r\n            // https://github.com/apollographql/apollo-client/issues/5870#issuecomment-689098185\r\n            const isEffectExecutedAfterRender = React.useRef(false);\r\n            isEffectExecutedAfterRender.current = false; // not yet...\r\n            \r\n            React.useEffect(() => {\r\n                isEffectExecutedAfterRender.current = true; // ... and now, yes!\r\n                // The state is not destroyed intentionally\r\n                // under hot reload case.\r\n                return () => { isEffectExecutedAfterRender.current && value.state.destroy() }\r\n            });\r\n        } else {\r\n            React.useEffect(() => () => value.state.destroy(), []);\r\n        }\r\n        const devtools = useState[DevToolsID]\r\n        if (devtools) {\r\n            result.attach(devtools)\r\n        }\r\n        return result.self;\r\n    }\r\n}\r\n\r\n/**\r\n * Allows to use a state without defining a functional react component.\r\n * It can be also used in class-based React components. It is also\r\n * particularly useful for creating *scoped* states.\r\n *\r\n * [Learn more...](https://hookstate.js.org/docs/using-without-statehook)\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport function StateFragment<S>(\r\n    props: {\r\n        state: State<S>,\r\n        children: (state: State<S>) => React.ReactElement,\r\n    }\r\n): React.ReactElement;\r\n/**\r\n * Allows to use a state without defining a functional react component.\r\n * See more at [StateFragment](#statefragment)\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/using-without-statehook)\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport function StateFragment<S>(\r\n    props: {\r\n        state: SetInitialStateAction<S>,\r\n        children: (state: State<S>) => React.ReactElement,\r\n    }\r\n): React.ReactElement;\r\nexport function StateFragment<S>(\r\n    props: {\r\n        state: State<S> | SetInitialStateAction<S>,\r\n        children: (state: State<S>) => React.ReactElement,\r\n    }\r\n): React.ReactElement {\r\n    const scoped = useState(props.state as State<S>);\r\n    return props.children(scoped);\r\n}\r\n\r\n/**\r\n * A plugin which allows to opt-out from usage of Javascript proxies for\r\n * state usage tracking. It is useful for performance tuning.\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/performance-managed-rendering#downgraded-plugin)\r\n */\r\nexport function Downgraded(): Plugin { // tslint:disable-line: function-name\r\n    return {\r\n        id: DowngradedID\r\n    }\r\n}\r\n\r\n/**\r\n * For plugin developers only.\r\n * Reserved plugin ID for developers tools extension.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\r\nexport const DevToolsID = Symbol('DevTools');\r\n\r\n/**\r\n * Return type of [DevTools](#devtools).\r\n */\r\nexport interface DevToolsExtensions {\r\n    /**\r\n     * Assigns custom label to identify the state in the development tools\r\n     * @param name label for development tools\r\n     */\r\n    label(name: string): void;\r\n    /**\r\n     * Logs to the development tools\r\n     */\r\n    log(str: string, data?: any): void;    // tslint:disable-line: no-any\r\n}\r\n\r\n/**\r\n * Returns access to the development tools for a given state.\r\n * Development tools are delivered as optional plugins.\r\n * You can activate development tools from `@hookstate/devtools`package,\r\n * for example. If no development tools are activated,\r\n * it returns an instance of dummy tools, which do nothing, when called.\r\n * \r\n * [Learn more...](https://hookstate.js.org/docs/devtools)\r\n * \r\n * @param state A state to relate to the extension.\r\n * \r\n * @returns Interface to interact with the development tools for a given state.\r\n * \r\n * @typeparam S Type of a value of a state\r\n */\r\nexport function DevTools<S>(state: State<S>): DevToolsExtensions {\r\n    const plugin = state.attach(DevToolsID);\r\n    if (plugin[0] instanceof Error) {\r\n        return EmptyDevToolsExtensions;\r\n    }\r\n    return plugin[0] as DevToolsExtensions;\r\n}\r\n\r\n///\r\n/// INTERNAL SYMBOLS (LIBRARY IMPLEMENTATION)\r\n///\r\n\r\nconst isDevelopmentMode = typeof process === 'object' && \r\n    typeof process.env === 'object' &&\r\n    process.env.NODE_ENV === 'development'\r\n\r\nconst self = Symbol('self')\r\n\r\nconst EmptyDevToolsExtensions: DevToolsExtensions = {\r\n    label() { /* */ },\r\n    log() { /* */ }\r\n}\r\n\r\nenum ErrorId {\r\n    InitStateToValueFromState = 101,\r\n    SetStateToValueFromState = 102,\r\n    GetStateWhenPromised = 103,\r\n    SetStateWhenPromised = 104,\r\n    SetStateNestedToPromised = 105,\r\n    SetStateWhenDestroyed = 106,\r\n    ToJson_Value = 108,\r\n    ToJson_State = 109,\r\n    GetUnknownPlugin = 120,\r\n\r\n    SetProperty_State = 201,\r\n    SetProperty_Value = 202,\r\n    SetPrototypeOf_State = 203,\r\n    SetPrototypeOf_Value = 204,\r\n    PreventExtensions_State = 205,\r\n    PreventExtensions_Value = 206,\r\n    DefineProperty_State = 207,\r\n    DefineProperty_Value = 208,\r\n    DeleteProperty_State = 209,\r\n    DeleteProperty_Value = 210,\r\n    Construct_State = 211,\r\n    Construct_Value = 212,\r\n    Apply_State = 213,\r\n    Apply_Value = 214,\r\n}\r\n\r\nclass StateInvalidUsageError extends Error {\r\n    constructor(path: Path, id: ErrorId, details?: string) {\r\n        super(`Error: HOOKSTATE-${id} [path: /${path.join('/')}${details ? `, details: ${details}` : ''}]. ` +\r\n            `See https://hookstate.js.org/docs/exceptions#hookstate-${id}`)\r\n    }\r\n}\r\n\r\ninterface Subscriber {\r\n    onSet(paths: Path[], actions: (() => void)[]): void;\r\n}\r\n\r\ninterface Subscribable {\r\n    subscribe(l: Subscriber): void;\r\n    unsubscribe(l: Subscriber): void;\r\n}\r\n\r\nfunction isNoProxyInitializer() {\r\n    try {\r\n        const used = new Proxy({}, {});\r\n        return false;\r\n    } catch (e) {\r\n        return true;\r\n    }\r\n};\r\nconst IsNoProxy = isNoProxyInitializer()\r\n\r\nconst DowngradedID = Symbol('Downgraded');\r\nconst SelfMethodsID = Symbol('ProxyMarker');\r\n\r\nconst RootPath: Path = [];\r\nconst DestroyedEdition = -1\r\n\r\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\r\n\r\nclass Store implements Subscribable {\r\n    private _edition = 0;\r\n\r\n    private _subscribers: Set<Subscriber> = new Set();\r\n    private _setSubscribers: Set<Required<PluginCallbacks>['onSet']> = new Set();\r\n    private _destroySubscribers: Set<Required<PluginCallbacks>['onDestroy']> = new Set();\r\n    private _batchStartSubscribers: Set<Required<PluginCallbacks>['onBatchStart']> = new Set();\r\n    private _batchFinishSubscribers: Set<Required<PluginCallbacks>['onBatchFinish']> = new Set();\r\n\r\n    private _plugins: Map<symbol, PluginCallbacks> = new Map();\r\n\r\n    private _promised?: Promised;\r\n\r\n    private _batches = 0;\r\n    private _batchesPendingPaths?: Path[];\r\n    private _batchesPendingActions?: (() => void)[];\r\n\r\n    constructor(private _value: StateValueAtRoot) {\r\n        if (typeof _value === 'object' &&\r\n            Promise.resolve(_value) === _value) {\r\n            this._promised = this.createPromised(_value)\r\n            this._value = none\r\n        } else if (_value === none) {\r\n            this._promised = this.createPromised(undefined)\r\n        }\r\n    }\r\n\r\n    createPromised(newValue: StateValueAtPath | undefined) {\r\n        const promised = new Promised(\r\n            newValue ? Promise.resolve(newValue) : undefined,\r\n            (r: StateValueAtPath) => {\r\n                if (this.promised === promised && this.edition !== DestroyedEdition) {\r\n                    this._promised = undefined\r\n                    this.set(RootPath, r, undefined)\r\n                    this.update([RootPath])\r\n                }\r\n            },\r\n            () => {\r\n                if (this.promised === promised && this.edition !== DestroyedEdition) {\r\n                    this._edition += 1\r\n                    this.update([RootPath])\r\n                }\r\n            },\r\n            () => {\r\n                if (this._batchesPendingActions &&\r\n                    this._value !== none &&\r\n                    this.edition !== DestroyedEdition) {\r\n                    const actions = this._batchesPendingActions\r\n                    this._batchesPendingActions = undefined\r\n                    actions.forEach(a => a())\r\n                }\r\n            }\r\n        );\r\n        return promised;\r\n    }\r\n\r\n    get edition() {\r\n        return this._edition;\r\n    }\r\n\r\n    get promised() {\r\n        return this._promised;\r\n    }\r\n\r\n    get(path: Path) {\r\n        let result = this._value;\r\n        if (result === none) {\r\n            return result;\r\n        }\r\n        path.forEach(p => {\r\n            result = result[p];\r\n        });\r\n        return result;\r\n    }\r\n\r\n    set(path: Path, value: StateValueAtPath, mergeValue: Partial<StateValueAtPath> | undefined): Path {\r\n        if (this._edition < 0) {\r\n            throw new StateInvalidUsageError(path, ErrorId.SetStateWhenDestroyed)\r\n        }\r\n\r\n        if (path.length === 0) {\r\n            // Root value UPDATE case,\r\n\r\n            const onSetArg: Writeable<PluginCallbacksOnSetArgument> = {\r\n                path: path,\r\n                state: value,\r\n                value: value,\r\n                previous: this._value,\r\n                merged: mergeValue\r\n            }\r\n            if (value === none) {\r\n                this._promised = this.createPromised(undefined)\r\n                delete onSetArg.value\r\n                delete onSetArg.state\r\n            } else if (typeof value === 'object' && Promise.resolve(value) === value) {\r\n                this._promised = this.createPromised(value)\r\n                value = none\r\n                delete onSetArg.value\r\n                delete onSetArg.state\r\n            } else if (this._promised && (!this._promised.resolver && !this._promised.fullfilled)) {\r\n                throw new StateInvalidUsageError(path, ErrorId.SetStateWhenPromised)\r\n            }\r\n\r\n            let prevValue = this._value;\r\n            if (prevValue === none) {\r\n                delete onSetArg.previous\r\n            }\r\n            this._value = value;\r\n            this.afterSet(onSetArg)\r\n\r\n            if (prevValue === none && this._value !== none &&\r\n                this.promised && this.promised.resolver) {\r\n                this.promised.resolver(this._value)\r\n            }\r\n\r\n            return path;\r\n        }\r\n\r\n        if (typeof value === 'object' && Promise.resolve(value) === value) {\r\n            throw new StateInvalidUsageError(path, ErrorId.SetStateNestedToPromised)\r\n        }\r\n\r\n        let target = this._value;\r\n        for (let i = 0; i < path.length - 1; i += 1) {\r\n            target = target[path[i]];\r\n        }\r\n\r\n        const p = path[path.length - 1]\r\n        if (p in target) {\r\n            if (value !== none) {\r\n                // Property UPDATE case\r\n                let prevValue = target[p]\r\n                target[p] = value;\r\n                this.afterSet({\r\n                    path: path,\r\n                    state: this._value,\r\n                    value: value,\r\n                    previous: prevValue,\r\n                    merged: mergeValue\r\n                })\r\n\r\n                return path;\r\n            } else {\r\n                // Property DELETE case\r\n                let prevValue = target[p]\r\n                if (Array.isArray(target) && typeof p === 'number') {\r\n                    target.splice(p, 1)\r\n                } else {\r\n                    delete target[p]\r\n                }\r\n                this.afterSet({\r\n                    path: path,\r\n                    state: this._value,\r\n                    previous: prevValue,\r\n                    merged: mergeValue\r\n                })\r\n\r\n                // if an array of objects is about to loose existing property\r\n                // we consider it is the whole object is changed\r\n                // which is identified by upper path\r\n                return path.slice(0, -1)\r\n            }\r\n        }\r\n\r\n        if (value !== none) {\r\n            // Property INSERT case\r\n            target[p] = value;\r\n            this.afterSet({\r\n                path: path,\r\n                state: this._value,\r\n                value: value,\r\n                merged: mergeValue\r\n            })\r\n\r\n            // if an array of objects is about to be extended by new property\r\n            // we consider it is the whole object is changed\r\n            // which is identified by upper path\r\n            return path.slice(0, -1)\r\n        }\r\n\r\n        // Non-existing property DELETE case\r\n        // no-op\r\n        return path;\r\n    }\r\n\r\n    update(paths: Path[]) {\r\n        if (this._batches) {\r\n            this._batchesPendingPaths = this._batchesPendingPaths || []\r\n            this._batchesPendingPaths = this._batchesPendingPaths.concat(paths)\r\n            return;\r\n        }\r\n\r\n        const actions: (() => void)[] = [];\r\n        this._subscribers.forEach(s => s.onSet(paths, actions));\r\n        actions.forEach(a => a());\r\n    }\r\n\r\n    afterSet(params: PluginCallbacksOnSetArgument) {\r\n        if (this._edition !== DestroyedEdition) {\r\n            this._edition += 1;\r\n            this._setSubscribers.forEach(cb => cb(params))\r\n        }\r\n    }\r\n\r\n    startBatch(path: Path, options?: { context?:  AnyContext }): void {\r\n        this._batches += 1\r\n\r\n        const cbArgument: Writeable<PluginCallbacksOnBatchArgument> = {\r\n            path: path\r\n        }\r\n        if (options && 'context' in options) {\r\n            cbArgument.context = options.context\r\n        }\r\n        if (this._value !== none) {\r\n            cbArgument.state = this._value\r\n        }\r\n        this._batchStartSubscribers.forEach(cb => cb(cbArgument))\r\n    }\r\n\r\n    finishBatch(path: Path, options?: { context?:  AnyContext }): void {\r\n        const cbArgument: Writeable<PluginCallbacksOnBatchArgument> = {\r\n            path: path\r\n        }\r\n        if (options && 'context' in options) {\r\n            cbArgument.context = options.context\r\n        }\r\n        if (this._value !== none) {\r\n            cbArgument.state = this._value\r\n        }\r\n        this._batchFinishSubscribers.forEach(cb => cb(cbArgument))\r\n\r\n        this._batches -= 1\r\n        if (this._batches === 0) {\r\n            if (this._batchesPendingPaths) {\r\n                const paths = this._batchesPendingPaths\r\n                this._batchesPendingPaths = undefined\r\n                this.update(paths)\r\n            }\r\n        }\r\n    }\r\n\r\n    postponeBatch(action: () => void): void {\r\n        this._batchesPendingActions = this._batchesPendingActions || []\r\n        this._batchesPendingActions.push(action)\r\n    }\r\n\r\n    getPlugin(pluginId: symbol) {\r\n        return this._plugins.get(pluginId)\r\n    }\r\n\r\n    register(plugin: Plugin) {\r\n        const existingInstance = this._plugins.get(plugin.id)\r\n        if (existingInstance) {\r\n            return;\r\n        }\r\n\r\n        const pluginCallbacks = plugin.init ? plugin.init(this.toMethods().self) : {};\r\n        this._plugins.set(plugin.id, pluginCallbacks);\r\n        if (pluginCallbacks.onSet) {\r\n            this._setSubscribers.add((p) => pluginCallbacks.onSet!(p))\r\n        }\r\n        if (pluginCallbacks.onDestroy) {\r\n            this._destroySubscribers.add((p) => pluginCallbacks.onDestroy!(p))\r\n        }\r\n        if (pluginCallbacks.onBatchStart) {\r\n            this._batchStartSubscribers.add((p) => pluginCallbacks.onBatchStart!(p))\r\n        }\r\n        if (pluginCallbacks.onBatchFinish) {\r\n            this._batchFinishSubscribers.add((p) => pluginCallbacks.onBatchFinish!(p))\r\n        }\r\n    }\r\n\r\n    toMethods() {\r\n        return new StateMethodsImpl<StateValueAtRoot>(\r\n            this,\r\n            RootPath,\r\n            this.get(RootPath),\r\n            this.edition,\r\n            OnSetUsedNoAction\r\n        )\r\n    }\r\n\r\n    subscribe(l: Subscriber) {\r\n        this._subscribers.add(l);\r\n    }\r\n\r\n    unsubscribe(l: Subscriber) {\r\n        this._subscribers.delete(l);\r\n    }\r\n\r\n    destroy() {\r\n        this._destroySubscribers.forEach(cb => cb(this._value !== none ? { state: this._value } : {}))\r\n        this._edition = DestroyedEdition\r\n    }\r\n\r\n    toJSON() {\r\n        throw new StateInvalidUsageError(RootPath, ErrorId.ToJson_Value);\r\n    }\r\n}\r\n\r\nclass Promised {\r\n    public fullfilled?: true;\r\n    public error?: StateErrorAtRoot;\r\n    public resolver?: (_: StateValueAtRoot) => void;\r\n\r\n    constructor(public promise: Promise<StateValueAtPath> | undefined,\r\n        onResolve: (r: StateValueAtPath) => void,\r\n        onReject: () => void,\r\n        onPostResolve: () => void) {\r\n        if (!promise) {\r\n            promise = new Promise<StateValueAtRoot>(resolve => {\r\n                this.resolver = resolve;\r\n            })\r\n        }\r\n        this.promise = promise\r\n            .then(r => {\r\n                this.fullfilled = true\r\n                if (!this.resolver) {\r\n                    onResolve(r)\r\n                }\r\n            })\r\n            .catch(err => {\r\n                this.fullfilled = true\r\n                this.error = err\r\n                onReject()\r\n            })\r\n            .then(() => onPostResolve())\r\n    }\r\n}\r\n\r\n// use symbol property to allow for easier reference finding\r\nconst ValueUnusedMarker = Symbol('ValueUnusedMarker');\r\n\r\nfunction OnSetUsedNoAction() { /** no action callback */ }\r\n\r\n// use symbol to mark that a function has no effect anymore\r\nconst UnmountedMarker = Symbol('UnmountedMarker');\r\nOnSetUsedNoAction[UnmountedMarker] = true\r\n\r\nclass StateMethodsImpl<S> implements StateMethods<S>, StateMethodsDestroy, Subscribable, Subscriber {\r\n    private subscribers: Set<Subscriber> | undefined;\r\n\r\n    private isDowngraded: boolean | undefined;\r\n    private childrenCache: Record<string | number, StateMethodsImpl<StateValueAtPath>> | undefined;\r\n    private selfCache: State<S> | undefined;\r\n    private valueCache: StateValueAtPath = ValueUnusedMarker;\r\n    \r\n    constructor(\r\n        public readonly state: Store,\r\n        public readonly path: Path,\r\n        private valueSource: S,\r\n        private valueEdition: number,\r\n        private readonly onSetUsed: () => void\r\n    ) { }\r\n\r\n    getUntracked(allowPromised?: boolean) {\r\n        if (this.valueEdition !== this.state.edition) {\r\n            this.valueSource = this.state.get(this.path)\r\n            this.valueEdition = this.state.edition\r\n\r\n            if (this.isMounted) {\r\n                // this link is still mounted to a component\r\n                // populate cache again to ensure correct tracking of usage\r\n                // when React scans which states to rerender on update\r\n                if (this.valueCache !== ValueUnusedMarker) {\r\n                    this.valueCache = ValueUnusedMarker\r\n                    this.get(true) // renew cache to keep it marked used\r\n                }\r\n            } else {\r\n                // This link is not mounted to a component\r\n                // for example, it might be global link or\r\n                // a link which has been discarded after rerender\r\n                // but still captured by some callback or an effect.\r\n                // If we are here and if it was mounted before,\r\n                // it means it has not been garbage collected\r\n                // when a component unmounted.\r\n                // We take this opportunity to clean up caches\r\n                // to avoid memory leaks via stale children states cache.\r\n                this.valueCache = ValueUnusedMarker\r\n                delete this.childrenCache\r\n                delete this.selfCache\r\n            }\r\n        }\r\n        if (this.valueSource === none && !allowPromised) {\r\n            if (this.state.promised && this.state.promised.error) {\r\n                throw this.state.promised.error;\r\n            }\r\n            throw new StateInvalidUsageError(this.path, ErrorId.GetStateWhenPromised)\r\n        }\r\n        return this.valueSource;\r\n    }\r\n\r\n    get(allowPromised?: boolean) {\r\n        const currentValue = this.getUntracked(allowPromised)\r\n        if (this.valueCache === ValueUnusedMarker) {\r\n            if (this.isDowngraded) {\r\n                this.valueCache = currentValue;\r\n            } else if (Array.isArray(currentValue)) {\r\n                this.valueCache = this.valueArrayImpl(currentValue as unknown as StateValueAtPath[]);\r\n            } else if (typeof currentValue === 'object' && currentValue !== null) {\r\n                this.valueCache = this.valueObjectImpl(currentValue as unknown as object);\r\n            } else {\r\n                this.valueCache = currentValue;\r\n            }\r\n        }\r\n        return this.valueCache as S;\r\n    }\r\n\r\n    get value(): S {\r\n        return this.get()\r\n    }\r\n\r\n    setUntracked(newValue: SetStateAction<S>, mergeValue?: Partial<StateValueAtPath>): [Path] {\r\n        if (typeof newValue === 'function') {\r\n            newValue = (newValue as ((prevValue: S) => S))(this.getUntracked());\r\n        }\r\n        if (typeof newValue === 'object' && newValue !== null && newValue[SelfMethodsID]) {\r\n            throw new StateInvalidUsageError(this.path, ErrorId.SetStateToValueFromState)\r\n        }\r\n        return [this.state.set(this.path, newValue, mergeValue)];\r\n    }\r\n\r\n    set(newValue: SetStateAction<S>) {\r\n        this.state.update(this.setUntracked(newValue));\r\n    }\r\n\r\n    mergeUntracked(sourceValue: SetPartialStateAction<S>): Path[] {\r\n        const currentValue = this.getUntracked()\r\n        if (typeof sourceValue === 'function') {\r\n            sourceValue = (sourceValue as Function)(currentValue);\r\n        }\r\n\r\n        let updatedPaths: [Path];\r\n        let deletedOrInsertedProps = false\r\n\r\n        if (Array.isArray(currentValue)) {\r\n            if (Array.isArray(sourceValue)) {\r\n                return this.setUntracked(currentValue.concat(sourceValue) as unknown as S, sourceValue)\r\n            } else {\r\n                const deletedIndexes: number[] = []\r\n                Object.keys(sourceValue).sort().forEach(i => {\r\n                    const index = Number(i);\r\n                    const newPropValue = sourceValue[index]\r\n                    if (newPropValue === none) {\r\n                        deletedOrInsertedProps = true\r\n                        deletedIndexes.push(index)\r\n                    } else {\r\n                        deletedOrInsertedProps = deletedOrInsertedProps || !(index in currentValue);\r\n                        (currentValue as StateValueAtPath[])[index] = newPropValue\r\n                    }\r\n                });\r\n                // indexes are ascending sorted as per above\r\n                // so, delete one by one from the end\r\n                // this way index positions do not change\r\n                deletedIndexes.reverse().forEach(p => {\r\n                    (currentValue as unknown as []).splice(p, 1)\r\n                })\r\n                updatedPaths = this.setUntracked(currentValue, sourceValue)\r\n            }\r\n        } else if (typeof currentValue === 'object' && currentValue !== null) {\r\n            Object.keys(sourceValue).forEach(key => {\r\n                const newPropValue = sourceValue[key]\r\n                if (newPropValue === none) {\r\n                    deletedOrInsertedProps = true\r\n                    delete currentValue[key]\r\n                } else {\r\n                    deletedOrInsertedProps = deletedOrInsertedProps || !(key in currentValue)\r\n                    currentValue[key] = newPropValue\r\n                }\r\n            })\r\n            updatedPaths = this.setUntracked(currentValue, sourceValue)\r\n        } else if (typeof currentValue === 'string') {\r\n            return this.setUntracked((currentValue + String(sourceValue)) as unknown as S, sourceValue)\r\n        } else {\r\n            return this.setUntracked(sourceValue as S)\r\n        }\r\n\r\n        if (updatedPaths.length !== 1 || updatedPaths[0] !== this.path || deletedOrInsertedProps) {\r\n            return updatedPaths\r\n        }\r\n        const updatedPath = updatedPaths[0]\r\n        return Object.keys(sourceValue).map(p => updatedPath.slice().concat(p))\r\n    }\r\n\r\n    merge(sourceValue: SetPartialStateAction<S>) {\r\n        this.state.update(this.mergeUntracked(sourceValue));\r\n    }\r\n\r\n    nested<K extends keyof S>(key: K): State<S[K]> {\r\n        return this.child(key as string | number).self as State<S[K]>\r\n    }\r\n    \r\n    rerender(paths: Path[]) {\r\n        this.state.update(paths)\r\n    }\r\n\r\n    destroy(): void {\r\n        this.state.destroy()\r\n    }\r\n\r\n    subscribe(l: Subscriber) {\r\n        if (this.subscribers === undefined) {\r\n            this.subscribers = new Set();\r\n        }\r\n        this.subscribers.add(l);\r\n    }\r\n\r\n    unsubscribe(l: Subscriber) {\r\n        this.subscribers!.delete(l);\r\n    }\r\n    \r\n    get isMounted(): boolean {\r\n        return !this.onSetUsed[UnmountedMarker]\r\n    }\r\n\r\n    onUnmount() {\r\n        this.onSetUsed[UnmountedMarker] = true\r\n    }\r\n\r\n    onSet(paths: Path[], actions: (() => void)[]): boolean {\r\n        const update = () => {\r\n            if (this.isDowngraded && this.valueCache !== ValueUnusedMarker) {\r\n                actions.push(this.onSetUsed);\r\n                return true;\r\n            }\r\n            for (let path of paths) {\r\n                const firstChildKey = path[this.path.length];\r\n                if (firstChildKey === undefined) {\r\n                    if (this.valueCache !== ValueUnusedMarker) {\r\n                        actions.push(this.onSetUsed);\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    const firstChildValue = this.childrenCache && this.childrenCache[firstChildKey];\r\n                    if (firstChildValue && firstChildValue.onSet(paths, actions)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        const updated = update();\r\n        if (!updated && this.subscribers !== undefined) {\r\n            this.subscribers.forEach(s => {\r\n                s.onSet(paths, actions)\r\n            })\r\n        }\r\n        return updated;\r\n    }\r\n\r\n    get keys(): InferredStateKeysType<S> {\r\n        const value = this.get()\r\n        if (Array.isArray(value)) {\r\n            return Object.keys(value).map(i => Number(i)).filter(i => Number.isInteger(i)) as\r\n                unknown as InferredStateKeysType<S>;\r\n        }\r\n        if (typeof value === 'object' && value !== null) {\r\n            return Object.keys(value) as unknown as InferredStateKeysType<S>;\r\n        }\r\n        return undefined as InferredStateKeysType<S>;\r\n    }\r\n\r\n    child(key: number | string) {\r\n        // if this state is not mounted to a hook,\r\n        // we do not cache children to avoid unnecessary memory leaks\r\n        if (this.isMounted) {\r\n            this.childrenCache = this.childrenCache || {};\r\n            const cachehit = this.childrenCache[key];\r\n            if (cachehit) {\r\n                return cachehit;\r\n            }\r\n        }\r\n        const r = new StateMethodsImpl(\r\n            this.state,\r\n            this.path.slice().concat(key),\r\n            this.valueSource[key],\r\n            this.valueEdition,\r\n            this.onSetUsed,\r\n        )\r\n        if (this.isDowngraded) {\r\n            r.isDowngraded = true;\r\n        }\r\n        if (this.childrenCache) {\r\n            this.childrenCache[key] = r;\r\n        }\r\n        return r;\r\n    }\r\n    \r\n    private valueArrayImpl(currentValue: StateValueAtPath[]): S {\r\n        if (IsNoProxy) {\r\n            this.isDowngraded = true\r\n            return currentValue as unknown as S;\r\n        }\r\n        return proxyWrap(this.path, currentValue,\r\n            () => currentValue,\r\n            (target: object, key: PropertyKey) => {\r\n                if (key === 'length') {\r\n                    return (target as []).length;\r\n                }\r\n                if (key in Array.prototype) {\r\n                    return Array.prototype[key];\r\n                }\r\n                if (key === SelfMethodsID) {\r\n                    return this;\r\n                }\r\n                if (typeof key === 'symbol') {\r\n                    // allow clients to associate hidden cache with state values\r\n                    return target[key];\r\n                }\r\n                const index = Number(key);\r\n                if (!Number.isInteger(index)) {\r\n                    return undefined;\r\n                }\r\n                return this.child(index).get();\r\n            },\r\n            (target: object, key: PropertyKey, value: StateValueAtPath) => {\r\n                if (typeof key === 'symbol') {\r\n                    // allow clients to associate hidden cache with state values\r\n                    target[key] = value;\r\n                    return true;\r\n                }\r\n                throw new StateInvalidUsageError(this.path, ErrorId.SetProperty_Value)\r\n            },\r\n            true\r\n        ) as unknown as S;\r\n    }\r\n\r\n    private valueObjectImpl(currentValue: object): S {\r\n        if (IsNoProxy) {\r\n            this.isDowngraded = true\r\n            return currentValue as unknown as S;\r\n        }\r\n        return proxyWrap(this.path, currentValue,\r\n            () => currentValue,\r\n            (target: object, key: PropertyKey) => {\r\n                if (key === SelfMethodsID) {\r\n                    return this;\r\n                }\r\n                if (typeof key === 'symbol') {\r\n                    // allow clients to associate hidden cache with state values\r\n                    return target[key];\r\n                }\r\n                return this.child(key).get();\r\n            },\r\n            (target: object, key: PropertyKey, value: StateValueAtPath) => {\r\n                if (typeof key === 'symbol') {\r\n                    // allow clients to associate hidden cache with state values\r\n                    target[key] = value;\r\n                    return true;\r\n                }\r\n                throw new StateInvalidUsageError(this.path, ErrorId.SetProperty_Value)\r\n            },\r\n            true\r\n        ) as unknown as S;\r\n    }\r\n\r\n    get self(): State<S> {\r\n        if (this.selfCache) {\r\n            return this.selfCache\r\n        }\r\n        \r\n        const getter = (_: object, key: PropertyKey) => {\r\n            if (key === self) {\r\n                return this\r\n            }\r\n            if (typeof key === 'symbol') {\r\n                return undefined\r\n            }\r\n            if (key === 'toJSON') {\r\n                throw new StateInvalidUsageError(this.path, ErrorId.ToJson_State);\r\n            }\r\n            \r\n            let nestedGetter = (prop: PropertyKey) => {\r\n                const currentDowngraded = this.isDowngraded; // relevant for IE11 only\r\n                const currentValue = this.get(); // IE11 marks this as downgraded\r\n                this.isDowngraded = currentDowngraded; // relevant for IE11 only\r\n                if (// if currentValue is primitive type\r\n                    (typeof currentValue !== 'object' || currentValue === null) &&\r\n                    // if promised, it will be none\r\n                    currentValue !== none) {\r\n                    // This was an error case, but various tools like webpack bundler\r\n                    // and react dev tools attempt to get props out of non-null object,\r\n                    // so this was changed to return just undefined for any property request\r\n                    // as there is no way to fix 3rd party tools.\r\n                    // Logging a warning to console is also not an option\r\n                    // as it pollutes console for legitimate apps on app start app.\r\n                    // Ref: https://github.com/avkonst/hookstate/issues/125\r\n                    return undefined\r\n                }\r\n\r\n                if (Array.isArray(currentValue)) {\r\n                    if (prop === 'length') {\r\n                        return currentValue.length;\r\n                    }\r\n                    if (prop in Array.prototype) {\r\n                        return Array.prototype[prop];\r\n                    }\r\n                    const index = Number(prop);\r\n                    if (!Number.isInteger(index)) {\r\n                        return undefined;\r\n                    }\r\n                    return this.nested(index as keyof S)\r\n                }\r\n                return this.nested(prop.toString() as keyof S)\r\n            }\r\n\r\n            switch (key) {\r\n                case 'path':\r\n                    return this.path\r\n                case 'keys':\r\n                    return this.keys\r\n                case 'value':\r\n                    return this.value\r\n                case 'ornull':\r\n                    return this.ornull\r\n                case 'promised':\r\n                    return this.promised\r\n                case 'error':\r\n                    return this.error\r\n                case 'get':\r\n                    return () => this.get()\r\n                case 'set':\r\n                    return (p: SetStateAction<S>) => this.set(p)\r\n                case 'merge':\r\n                    return (p: SetPartialStateAction<S>) => this.merge(p)\r\n                case 'nested':\r\n                    return (p: keyof S) => nestedGetter(p)\r\n                case 'batch':\r\n                    // tslint:disable-next-line: no-any\r\n                    return <R, C>(action: () => R, context: Exclude<C, Function>) => this.batch(action, context)\r\n                case 'attach':\r\n                    return (p: symbol) => this.attach(p)\r\n                case 'destroy':\r\n                    return () => this.destroy()\r\n                default:\r\n                    return nestedGetter(key)\r\n            }\r\n        }\r\n        \r\n        if (IsNoProxy) {\r\n            // minimal support for IE11\r\n            const result = (Array.isArray(this.valueSource) ? [] : {}) as State<S>;\r\n            [self, 'toJSON', 'path', 'keys', 'value', 'ornull',\r\n                'promised', 'error', 'get', 'set', 'merge',\r\n                'nested', 'batch', 'attach', 'destroy']\r\n            .forEach(key => {\r\n                Object.defineProperty(result, key, {\r\n                    get: () => getter(result, key)\r\n                })\r\n            })\r\n            if (typeof this.valueSource === 'object' && this.valueSource !== null) {\r\n                Object.keys(this.valueSource).forEach(key => {\r\n                    Object.defineProperty(result, key, {\r\n                        enumerable: true,\r\n                        get: () => getter(result, key)\r\n                    })\r\n                })\r\n            }\r\n            this.selfCache = result;\r\n            return this.selfCache\r\n        }\r\n        \r\n        this.selfCache = proxyWrap(this.path, this.valueSource,\r\n            () => {\r\n                this.get() // get latest & mark used\r\n                return this.valueSource\r\n            },\r\n            getter,\r\n            (_, key, value) => {\r\n                throw new StateInvalidUsageError(this.path, ErrorId.SetProperty_State)\r\n            },\r\n            false) as unknown as State<S>;\r\n        return this.selfCache\r\n    }\r\n    \r\n    get promised(): boolean {\r\n        const currentValue = this.get(true) // marks used\r\n        if (currentValue === none && this.state.promised && !this.state.promised.fullfilled) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    get error(): StateErrorAtRoot | undefined {\r\n        const currentValue = this.get(true) // marks used\r\n        if (currentValue === none) {\r\n            if (this.state.promised && this.state.promised.fullfilled) {\r\n                return this.state.promised.error;\r\n            }\r\n            this.get() // will throw 'read while promised' exception\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    batch<R, C>(\r\n        action: (s: State<S>) => R,\r\n        context?: Exclude<C, Function>\r\n    ): R {\r\n        const opts = { context: context }\r\n        try {\r\n            this.state.startBatch(this.path, opts)\r\n            const result = action(this.self) as R\r\n            if (result as unknown as Symbol === postpone) {\r\n                this.state.postponeBatch(() => this.batch(action, context))\r\n            }\r\n            return result\r\n        } finally {\r\n            this.state.finishBatch(this.path, opts)\r\n        }\r\n    }\r\n\r\n    get ornull(): InferredStateOrnullType<S> {\r\n        const value = this.get()\r\n        if (value === null || value === undefined) {\r\n            return value as unknown as InferredStateOrnullType<S>;\r\n        }\r\n        return this.self as InferredStateOrnullType<S>;\r\n    }\r\n\r\n    attach(plugin: () => Plugin): State<S>\r\n    attach(pluginId: symbol): [PluginCallbacks | Error, PluginStateControl<S>]\r\n    attach(p: (() => Plugin) | symbol):\r\n        State<S> | [PluginCallbacks | Error, PluginStateControl<S>] {\r\n        if (typeof p === 'function') {\r\n            const pluginMeta = p();\r\n            if (pluginMeta.id === DowngradedID) {\r\n                this.isDowngraded = true;\r\n                if (this.valueCache !== ValueUnusedMarker) {\r\n                    const currentValue = this.getUntracked(true);\r\n                    this.valueCache = currentValue;\r\n                }\r\n                return this.self;\r\n            }\r\n            this.state.register(pluginMeta);\r\n            return this.self;\r\n        } else {\r\n            return [\r\n                this.state.getPlugin(p) ||\r\n                    (new StateInvalidUsageError(this.path, ErrorId.GetUnknownPlugin, p.toString())), \r\n                this\r\n            ];\r\n        }\r\n    }\r\n}\r\n\r\nfunction proxyWrap(\r\n    path: Path,\r\n    // tslint:disable-next-line: no-any\r\n    targetBootstrap: any,\r\n    // tslint:disable-next-line: no-any\r\n    targetGetter: () => any,\r\n    // tslint:disable-next-line: no-any\r\n    propertyGetter: (unused: any, key: PropertyKey) => any,\r\n    // tslint:disable-next-line: no-any\r\n    propertySetter: (unused: any, p: PropertyKey, value: any, receiver: any) => boolean,\r\n    isValueProxy: boolean\r\n) {\r\n    const onInvalidUsage = (op: ErrorId) => {\r\n        throw new StateInvalidUsageError(path, op)\r\n    }\r\n    if (typeof targetBootstrap !== 'object' || targetBootstrap === null) {\r\n        targetBootstrap = {}\r\n    }\r\n    return new Proxy(targetBootstrap, {\r\n        getPrototypeOf: (target) => {\r\n            // should satisfy the invariants:\r\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf#Invariants\r\n            const targetReal = targetGetter()\r\n            if (targetReal === undefined || targetReal === null) {\r\n                return null;\r\n            }\r\n            return Object.getPrototypeOf(targetReal);\r\n        },\r\n        setPrototypeOf: (target, v) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.SetPrototypeOf_State :\r\n                ErrorId.SetPrototypeOf_Value)\r\n        },\r\n        isExtensible: (target) => {\r\n            // should satisfy the invariants:\r\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible#Invariants\r\n            return true; // required to satisfy the invariants of the getPrototypeOf\r\n            // return Object.isExtensible(target);\r\n        },\r\n        preventExtensions: (target) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.PreventExtensions_State :\r\n                ErrorId.PreventExtensions_Value)\r\n        },\r\n        getOwnPropertyDescriptor: (target, p) => {\r\n            const targetReal = targetGetter()\r\n            if (targetReal === undefined || targetReal === null) {\r\n                return undefined;\r\n            }\r\n            const origin = Object.getOwnPropertyDescriptor(targetReal, p);\r\n            if (origin && Array.isArray(targetReal) && p in Array.prototype) {\r\n                return origin;\r\n            }\r\n            return origin && {\r\n                configurable: true, // JSON.stringify() does not work for an object without it\r\n                enumerable: origin.enumerable,\r\n                get: () => propertyGetter(targetReal, p),\r\n                set: undefined\r\n            };\r\n        },\r\n        has: (target, p) => {\r\n            if (typeof p === 'symbol') {\r\n                return false;\r\n            }\r\n            const targetReal = targetGetter()\r\n            if (typeof targetReal === 'object' && targetReal !== null) {\r\n                return p in targetReal;\r\n            }\r\n            return false;\r\n        },\r\n        get: propertyGetter,\r\n        set: propertySetter,\r\n        deleteProperty: (target, p) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.DeleteProperty_State :\r\n                ErrorId.DeleteProperty_Value)\r\n        },\r\n        defineProperty: (target, p, attributes) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.DefineProperty_State :\r\n                ErrorId.DefineProperty_Value)\r\n        },\r\n        ownKeys: (target) => {\r\n            const targetReal = targetGetter()\r\n            if (Array.isArray(targetReal)) {\r\n                return Object.keys(targetReal).concat('length');\r\n            }\r\n            if (targetReal === undefined || targetReal === null) {\r\n                return [];\r\n            }\r\n            return Object.keys(targetReal);\r\n        },\r\n        apply: (target, thisArg, argArray?) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.Apply_State:\r\n                ErrorId.Apply_Value)\r\n        },\r\n        construct: (target, argArray, newTarget?) => {\r\n            return onInvalidUsage(isValueProxy ?\r\n                ErrorId.Construct_State :\r\n                ErrorId.Construct_Value)\r\n        }\r\n    });\r\n}\r\n\r\nfunction createStore<S>(initial: SetInitialStateAction<S>): Store {\r\n    let initialValue: S | Promise<S> = initial as (S | Promise<S>);\r\n    if (typeof initial === 'function') {\r\n        initialValue = (initial as (() => S | Promise<S>))();\r\n    }\r\n    if (typeof initialValue === 'object' && initialValue !== null && initialValue[SelfMethodsID]) {\r\n        throw new StateInvalidUsageError(RootPath, ErrorId.InitStateToValueFromState)\r\n    }\r\n    return new Store(initialValue);\r\n}\r\n\r\n// Do not try to use useLayoutEffect if DOM not available (SSR)\r\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\r\n\r\nfunction useSubscribedStateMethods<S>(\r\n    state: Store,\r\n    path: Path,\r\n    update: () => void,\r\n    subscribeTarget: Subscribable\r\n) {\r\n    const link = new StateMethodsImpl<S>(\r\n        state,\r\n        path,\r\n        state.get(path),\r\n        state.edition,\r\n        update,\r\n    );\r\n    // useLayoutEffect here instead of useEffect because of this issue:\r\n    // https://github.com/avkonst/hookstate/issues/165#issuecomment-824670930\r\n    // and very likely this issue:\r\n    // https://github.com/avkonst/hookstate/issues/186\r\n    // and probably this issue:\r\n    // https://github.com/avkonst/hookstate/issues/145\r\n    // useIsomorphicLayout for below issue when page is SSR\r\n    // https://github.com/avkonst/hookstate/issues/223\r\n    useIsomorphicLayoutEffect(() => {\r\n        subscribeTarget.subscribe(link);\r\n        return () => {\r\n            link.onUnmount()\r\n            subscribeTarget.unsubscribe(link);\r\n        }\r\n    });\r\n    return link;\r\n}\r\n"],
  "mappings": "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",
  "names": ["d", "b", "React", "ErrorId", "StateInvalidUsageError", "Store", "Promised", "StateMethodsImpl"]
}
